\section{Vectorization}\label{sec:vectorization}
As we discussed in section \secref{profiling}, the majority of time is spent in the \ttt{sqare} function. Looking at the vectorization report generated by the compiler default code, we see that the compiler did not vectorize the \ttt{for} loop inside the \ttt{sqaure} function because it assumes dependencies in the loop.

\begin{verbatim}
LOOP BEGIN at mt19937p.c(59,5) inlined into path.c(228,14)
remark #15344: loop was not vectorized: vector dependence prevents vectorization
remark #15346: vector dependence: assumed FLOW dependence between mt line 60 and mt line 60
LOOP END
\end{verbatim}

To clear the dependency, we simply added \ttt{\#pragma} vector aligned in the inner loop as shown below to ensure the compiler that the lij is indeed aligned.  Adding the \ttt{\#pragma} instruction gave us a 4 times speed up to the \ttt{square} function. 


\begin{verbatim}
	#pragma omp parallel for shared(l, lnew) reduction (&& : done)
	for (int j = 0; j<n; ++j){
		for (int k = 0; k < n; ++k) {
			int lkj = l[j*n+k];
			
			#pragma vector aligned
			for (int i = 0; i < n; ++i){
				int lij = lnew[j*n+i];
				int lik = l[k*n+i];
				
				if (lik +lkj < lij){
				lij = lik+lkj;
				done=0;
				}
				
				lnew[j*n+i] = lij;
			}
		}
	}
\end{verbatim}


